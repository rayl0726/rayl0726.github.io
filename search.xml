<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>bigNumAdd</title>
      <link href="/2020/06/21/algorithms-bigNumAdd/"/>
      <url>/2020/06/21/algorithms-bigNumAdd/</url>
      
        <content type="html"><![CDATA[<p>今天做了一下两个大数相加的问题，java中偷懒的话可以直接bigDecimal类使用，自己觉得还是写一下练习</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bigNumAdd2</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">       BigDecimal decimal1 = <span class="keyword">new</span> BigDecimal(num1);</span><br><span class="line">       BigDecimal decimal2 = <span class="keyword">new</span> BigDecimal(num2);</span><br><span class="line"></span><br><span class="line">       BigDecimal result = decimal1.add(decimal2);</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是大数所以基本的long类型就存不下了，所以考虑字符串类型；</p><p>相加无非就是把个位，十位…加起来，所以用分解字符串的方法一位一位取出来相加，注意几个关键点：</p><ul><li>相加的时候要把数字的字符串倒序排列一下，因为是从个位开始，这里我用的是stringBuilder的reverse()方法；</li><li>过十进位，最高位可能会多一位，所以存储结果的字符串长度要多设置一位；</li><li>两个数的长度要注意会不一样，当循环超过较小的那个数的指针时要主要不要越界</li></ul><p>上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bigNumAdd1</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//翻转两个字符串</span></span><br><span class="line">       String chars1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString();</span><br><span class="line">       String chars2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString();</span><br><span class="line">       <span class="comment">//获取最大的字符串长度</span></span><br><span class="line">       <span class="keyword">int</span> maxlength = Math.max(chars1.length(), chars2.length());</span><br><span class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder(maxlength + <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxlength; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> tempNum1 = chars1.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (chars1.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">           <span class="keyword">int</span> tempNum2 = chars2.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (chars2.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">           <span class="keyword">int</span> tempNum = tempNum1 + tempNum2 + carry;</span><br><span class="line">           <span class="keyword">int</span> currentNum = tempNum % <span class="number">10</span>;</span><br><span class="line">           carry = tempNum / <span class="number">10</span>;</span><br><span class="line">           result.append(currentNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           result.append(carry);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 基本可以完成运算，但是这是一种只考虑整数的情况，如果是小数的情况其实也差不多一样，我想的方法是根据小数点拆分成两个字符串，整数部分同上，小数部分计算要注意：</p><ul><li><p>相加的时候不用倒序，直接加；</p></li><li><p>进位的问题要补到整数部分；</p></li><li><p>代码写的时候要注意边界问题；</p><p>上代码(我写的比较挫):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bigDecimalAdd</span><span class="params">(String num1, String num2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      String[] split1 = num1.split(<span class="string">"\\."</span>);</span><br><span class="line">      String[] split2 = num2.split(<span class="string">"\\."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(split1.length &gt; <span class="number">2</span> || split2.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"params wrong"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算小数部分</span></span><br><span class="line">      String float1 = <span class="keyword">null</span>;</span><br><span class="line">      String float2 = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(split1.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          float1 = split1[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(split2.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          float2 = split2[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取最大的字符串长度</span></span><br><span class="line">      <span class="keyword">int</span> maxlength = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(float1 == <span class="keyword">null</span> &amp;&amp; float2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(float1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">          maxlength = float2.length();</span><br><span class="line">          float1 = <span class="string">""</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(float2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">          maxlength = float1.length();</span><br><span class="line">          float2 = <span class="string">""</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          maxlength = Math.max(float1.length(), float2.length());</span><br><span class="line">      &#125;</span><br><span class="line">      StringBuilder floatResult = <span class="keyword">new</span> StringBuilder(maxlength + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> floatCarry = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(maxlength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxlength; i++) &#123;</span><br><span class="line">              <span class="keyword">int</span> tempNum1 = float1.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (float1.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">              <span class="keyword">int</span> tempNum2 = float2.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (float2.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">              <span class="keyword">int</span> tempNum = tempNum1 + tempNum2 + floatCarry;</span><br><span class="line">              <span class="keyword">int</span> currentNum = tempNum % <span class="number">10</span>;</span><br><span class="line">              floatCarry = tempNum / <span class="number">10</span>;</span><br><span class="line">              floatResult.append(currentNum);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String decimalResult = floatResult.toString();</span><br><span class="line">      String integerResult = bigIntegerAdd(split1[<span class="number">0</span>], split2[<span class="number">0</span>], floatCarry);</span><br><span class="line">      <span class="keyword">return</span> decimalResult.length() &gt; <span class="number">0</span> ? integerResult + <span class="string">"."</span> + decimalResult : integerResult;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中bigIntegerAdd（）方法是计算整数部分，并把小数部分的进位加了进去:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">bigIntegerAdd</span><span class="params">(String num1, String num2, <span class="keyword">int</span> floatCarry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//翻转两个字符串</span></span><br><span class="line">      String chars1 = <span class="keyword">new</span> StringBuilder(num1).reverse().toString();</span><br><span class="line">      String chars2 = <span class="keyword">new</span> StringBuilder(num2).reverse().toString();</span><br><span class="line">      <span class="comment">//获取最大的字符串长度</span></span><br><span class="line">      <span class="keyword">int</span> maxlength = Math.max(chars1.length(), chars2.length());</span><br><span class="line">      StringBuilder result = <span class="keyword">new</span> StringBuilder(maxlength + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxlength; i++) &#123;</span><br><span class="line">          <span class="keyword">int</span> tempNum1 = chars1.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (chars1.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">          <span class="keyword">int</span> tempNum2 = chars2.length() - <span class="number">1</span> &lt; i ? <span class="number">0</span> :  (chars2.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">          <span class="keyword">int</span> tempNum = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; floatCarry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              tempNum = tempNum1 + tempNum2 + carry + floatCarry;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              tempNum = tempNum1 + tempNum2 + carry;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> currentNum = tempNum % <span class="number">10</span>;</span><br><span class="line">          carry = tempNum / <span class="number">10</span>;</span><br><span class="line">          result.append(currentNum);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          result.append(carry);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当然还有其他的解法，有新的想法和对我代码提建议的可以留言~~</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发总结</title>
      <link href="/2020/06/07/java-concurrent/"/>
      <url>/2020/06/07/java-concurrent/</url>
      
        <content type="html"><![CDATA[<h2 id="一-概念："><a href="#一-概念：" class="headerlink" title="一 概念："></a>一 概念：</h2><ol><li><p>共享的：变量可以被多个线程访问，</p></li><li><p>可变的：变量在生命周期内可以发生变化，</p></li><li><p>原子性：复合操作保证要么都完成，要么都不完成，</p><a id="more"></a></li><li><p>竞态条件：不正确的执行顺序出现的不正确的执行结果，两个线程分别对一个数据操作，结果操作的顺序没有保证，会导致结果不正确，</p></li><li><p>先检查后执行（check-then-act）：先要判断变量a是否为1，再操作另外一个变量b，在这期间可能会有另外一个线程提前改变了变量b的值，这样导致数据不一致；其他异常情况：数据覆盖，文件破坏等<br>出现的情况：延迟初始化(将对象的初始化操作推迟到实际使用的时候才进行，并确保只被初始化一次），在初始化之前这段时间可能会造成判断条件不一致的情况。</p></li><li><p>内置锁（监视器锁）：每个java对象都可以作为一个实现同步的锁，</p></li><li><p>同步代码块：包含一个作为锁的对象引用，还有一个作为由这个所保护的代码块；线程在进入同步代码块之前会自动获得锁，并在退出同步代码块的时候自动释放锁；每次只有一个线程执行内置锁保护的代码，所以能保证代码块内的原子性</p></li><li><p>重入：某个线程试图获得一个已经由他持有的锁时，因为本身已经持有，还有一种情况jvm虚拟机做到了锁消除，不用再重新获取；</p></li><li><p>可见性（内存可见性）：读操作和写操作在不同的线程中执行的时候，为了确保不同线程写入内存的状态都能被各个线程看到，所以需要有同步的机制，在主内存上同步数据的一致；</p></li><li><p>重排序：编译器可以不按照代码的顺序编译指令，处理器也能不按照顺序执行指令，这是由重排序导致数据不正确；编译器会把变量直接存在寄存器中，处理器中的缓存数据其他处理器不可见，这个是由于不可见性导致数据不一致。</p></li><li><p>加锁和可见性：当线程a执行同步代码块中的操作后，释放锁，数据会清空缓存，更新主内存，这样下一次的线程b执行同步代码块时，会从内存中读取到同步的数据，保证了数据的可见性；</p></li><li><p>volatile：被volatile声明的变量，编译器不会把该变量进行重排序，变量不会缓存在寄存器或者处理器的本地缓存，这样保证了变量的可见性，读取该变量的时候总是返回最新的值。<br>用法：若把某个变量用作标记，将其声明为volatile类型，保证多线程修改的时候都可见，防止出现多线程操作后数据不一直的问题<br>和加锁的区别：加锁能够保证原子性和可见性，而volatile只能保证可见性。</p></li><li><p>发布：指变量能够被当前作用域之外的代码使用， </p><ul><li>方法1：将一个对象的引用保存到一个公有的静态变量中；</li><li>方法2：发布某个对象时会间接发布其他对象；</li><li>方法3：发布一个对象时，该对象的非私有域中引用的所有对象都也会被发布；</li><li>方法4：发布一个内部类；</li></ul></li><li><p>逸出：某个不该发布的对象被发布，不要在构造过程中使this引用逸出；<br>常见的this逸出，①在构造函数中启动一个线程，②在构造函数中调用一个可改写的实例方法时；<br>使用工厂方法防止this引用在构造过程中逸出。</p></li><li><p>线程封闭：在单线程中访问数据，数据不需要同步；当被访问的数据被封闭在一个线程中，即使该对象不是线程安全的，这种用法也将实现线程安全。<br>jdbc连接池的connection对象，每次访问的时候的线程获得一个connection对象，用完后再归还给连接池（链接池要保证线程安全），在归还之前，该对象不会分配给其他线程，这样保证了connection存在一个封闭的线程中，保证了线程安全。<br>①ad-hoc:维护线程封闭的职责完全由程序实现<br>②栈封闭：只能通过局部变量访问对象，将变量封闭成局部变量，由于方法在执行的时候会有自己的虚拟机栈，该栈在中的变量只有本线程能访问，所以保证了线程安全，<br>③ThreadLocal：将变量可以声明为全局的，不同的线程set不同的值，调用get的时候只会拿到自己线程的值，不会被别的线程覆盖</p></li><li><p>不变性：不可变对象一定是线程安全的，不可变对象只有一种状态，并有构造函数来控制；满足三个条件才是不可变的：①对象创建后其状态不能修改；②对象的所有域都是final类型；③对象是正确创建的（在创建对象的时候，this引用没有逸出）</p></li><li><p>final域：（反射修改final修饰的对象能否成功？）<br>写final域规则：保证final域修饰的变量在构造函数中执行，这样保证对象被引用的时候变量不会出现未初始化的情况；这里保证的是编译器不会重排序<br>读fianl域规则：初次读对象引用和初次读该对象包含的fina域，这两个操作禁止重排序，普通域的读操作很有可能被重排序到了写普通域之前；这里是禁止处理器重排序<br>对引用的final对象，会保证整个引用写入和成员写入完成后添加storestore屏障，读同样如此；在x86的系统中省略了这些屏障；<br>final 引用不能从构造函数中 逸出，否则不能保证对象构造完成，这样final 引用的变量也可能没有初始化完成。</p></li><li><p>安全发布：<br>在静态初始化函数中初始化一个对象的引用；用 volatile ， final， 或者锁 保护对象的引用；</p></li></ol><h2 id="二-对象的组合"><a href="#二-对象的组合" class="headerlink" title="二 对象的组合"></a>二 对象的组合</h2><ol><li>设计线程安全类的三要素：<br>①找出构成对象状态的所有变量<br>②找出约束状态变量的不变性条件<br>③建立对象状态的并发访问的管理策略</li><li>当下一个状态需要依赖前一个状态的时候，这个操作是一个复合操作，例如：CAS</li><li>包含多个变量的不变性条件时，会产生原子性需求：这些相关的变量必需在单个原子操作中进行</li><li>后验条件：当变量的状态改变之后，需要依赖之前的某个状态值作为验证的依据，但是变量的改变是成功的；</li><li>先验条件：也称为依赖状态的操作，变量在使用之前就要先校验，否则后续的原子操作可能会发生异常（单线程中），在并并发环境下，这个先验条件可能会被其他线程修改，导致验证成功，防止这样的情况可以把整个验证和操作都封装起来，或者变成原子性操作</li><li>状态的所有权，java的垃圾回收机制使我们避免处理所有权的问题，因为新的对象创建之后，内部包含的对象的状态的所有权是属于谁？7解答</li><li>对象封装它拥有的状态，反之，对他封装的状态拥有多有权</li><li>如果对象不是线程安全的，可以有多种方式把它封装使用保证安全，例如让该对象只能有单线程访问（线程封闭在线程中吧对象传递给另一个方法，而不是共享） ，或者通过锁保护，或者栈封闭（变成局部变量）。将对象封装在另一个对象中，并采用适当的加锁策略，可以确保线程安全，例如：装饰器模式（实例封闭的一种）。</li><li>监视器模式：把所有对象的可变状态都封装起来，并使用对象的内置锁来保护，简单的一个例子，在类中有个value 属性， 把get 和set都用synchinzed修饰，使用内置锁保护，这个简单的例子就是监视器模式的简单实现；实际情况可以使用内部私有的属性作为锁，但是要注意不能把公有的get和set方法泄露出去</li><li>线程安全性的委托：将线程的安全性委托给内部状态的安全性，比如使用currentHashMap代替hashMap，使用atomic类型值等；还可以委托给多个状态变量 ，前提这几个状态变量是互相独立的。</li><li>如果某个类含有复合操作，仅依靠委托是不足以实现安全的，委托的状态间可能有关联，或者委托的状态可能被发布导致状态失效，何时能发布状态交由用户修改，取决于该状态被修改后是否影响整个程序的安全性，也就是视情况而定…</li></ol><h2 id="三-基础构建模块"><a href="#三-基础构建模块" class="headerlink" title="三 基础构建模块"></a>三 基础构建模块</h2><ol><li>同步容器类：</li></ol><ul><li>同步容器类是线程安全的，但是在某些复合操作的情况下仍然会导致线程安全问题，如：迭代，跳转，条件运算（如果没有就添加），原因是这些操作是复合操作；</li><li>foreach使用的是iterator遍历：将计数器的变化容器关联，若在迭代期间计数器被修改，hasNext或next就会抛出ConcurrentModificationException，这样会对容器进行加锁；</li><li>如果不希望对容器加锁，还可以复制一份容器，这个容器被封闭在线程内部，其他线程不会修改，这样在副本上迭代就可以保证安全；</li><li>隐藏的迭代操作，标准容器的toString方法会迭代容器，所以假如在调用system.out.print的时候会隐式调用迭代，同样还有hashCode和equals，containsAll，removeAll，retainAll等方法；</li></ul><ol start="2"><li>并发容器：</li></ol><ul><li>conCurrentHashMap：正常的hashMap在查找某个元素时会用到equals，导致花费时间较长，这段时间在线程同步后会导致其他线程不能访问。currentHashMap采用分段锁，</li><li>分段锁：对散列桶的每个散列元素都添加一个锁，增加了锁的数量，读写不通锁的时候可以同时进行，提高并发的效率。</li><li>CopOnWriteArrayList：用于替代同步list，在迭代期间不需要对容器进行加锁或复制。它的安全性在于只要正确的发布一个事实不可变的对象，那么在访问该对象的时候就不需要再进一步同步。且基本的add等方法也进行了加锁处理，使得写操作线程安全，读操作可以多线程同入，若迭代，会获取一份当前的数据快照，迭代是对快照进行的，数据有变化的话也不会感知。</li></ul><ol start="3"><li>阻塞队列：<br>队列已满，put方法将阻塞直到有空间可用；队列为空，take将阻塞直到有元素可用。<br>阻塞队列支持生产者-消费者模式，同时提供offer，poll方法，若数据项不能被添加到队列中/获取数据的时候队列为空，那么将返回一个失败状态。<br>生产者-消费者可以并发的执行</li><li>串行线程封闭：线程封闭对象只能由单个线程拥有，但可以通过安全的发布该对象来转移所有权，转移后只能有新的线程来独占。要确保只有一个线程能接受被转移的可变对象。</li><li>双端队列：deque（双端队列） 实现了在队列头和队列尾的高效插入和移除。</li><li>工作密取（work stealing）：每个消费者都有自己的deque，当消费完自己的任务后可以从别的deque中获取任务，但是要从队尾获取。适用于既是生产者又是消费者。</li><li>阻塞方法：线程可能因为一些原因处于阻塞状态，被阻塞的线程必须等待某个不受它控制的时间发生后才能继续执行。</li><li>中断方法：中断是一种协作机制，一个线程不能强制停止其他正在运行的线程，中断只是要求另一个线程执行到可以暂停的地方停止正在执行的任务</li><li>同步工具类：可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。阻塞队列可以视为同步工具类，其他的还包括信号量，栅栏，闭锁。他们都封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高校等待同步工具类进入到预期状态。</li><li>闭锁：可以延迟线程的进度直到到达终止状态，闭锁相当于一扇门，在闭锁的状态结束前，没有任何线程能通过这扇门，当状态结束，门打开允许所有线程通过。</li><li>futureTask：通过callable实现，可以用作闭锁， Future的get方法相当于latch的await，阻塞当前线程，直到状态结束。状态结束后将永远停止在当前状态。在executor中它是异步任务。</li><li>信号量：用来控制同时访问某个特定资源的操作数量，或者同时执行某个操作的数量，释放可以由不同的线程执行，和互斥锁不一样。</li><li>栅栏（barrier）：对当前执行的线程来说等待其他线程都达到一定状态后才继续执行。</li></ol><h2 id="四-任务执行"><a href="#四-任务执行" class="headerlink" title="四 任务执行"></a>四 任务执行</h2><ol><li>任务：抽象的，离散的工作单元。围绕任务管理应用时，首先要指明任务边界，理想情况，任务是独立的活动，它的工作不依赖其他任务状态结果或者边界效应。独立的请求作为任务边界。</li><li>顺序的执行任务：吞吐量低，当处理方法存在阻塞的时候会严重影响服务器性能，响应慢。</li><li>显示创建多线程：将处理的方法放在每个线程中执行，可以提高吞吐量，但是无限制的创建线程在维持线程生命周期有开销，消耗内存和cpu资源，线程数量要有限制。</li><li>Executor：任务是一组逻辑工作单元，线程是使任务异步执行的机制。它提供了一种标准的方法将任务的提交过程和执行过程解耦，并用runnable表示。可以为任务选择指定的执行策略。</li><li>线程池：因为线程提前创建好，可以减少每次创建线程的开销，降低任务延迟，提高响应，复用线程资源。</li><li>生命周期：如果无法正确的关闭executor jvm将无法结束。executorService接口用于管理生命周期。</li><li>timer缺陷：①执行定时任务的时候只会创建一个线程。假设某个任务执行时间过长，可能会出现丢失任务的情况（取决于是固定速率还是固定延迟来调用任务）②timer如果抛出一个非受检异常，可能会把整个timer取消，导致后续的任务无法继续执行，所以推荐使用ScheduledThreadPoolExecutor。</li><li>callable：它认为主入口点（call）将返回一个值，这个值能够被future 拿到，并可能抛出异常，一般配合ExecutorService</li><li>future：表示一个任务的生命周期，提供了方法判断是否完成或者取消，以及获取任务结果和取消任务等。任务的的生命周期只能前进，也就是任务完成后就停留在完成的状态。 可以用来获取callable的结果，get()方法会阻塞。<br>异构任务并行的局限：当两个任务的执行效率差距过大时，拆分任务为并行性能提升很低，反而使代码变得更加复杂，所以只有当大量同构任务并行处理时，才能体现将程序工作分配到多个任务带来的性能提升。</li><li>completionService：可以利用一个Executor，把每个任务执行结束后存储到blockingqueue中，调用take() 将返回future，目的是为了让串行的执行task变成并行的执行，提高效率。</li><li>invokeAll：可以一次唤醒多个future，并可以设置等待的时间，超过将抛出CancellationException异常，此时可以执行取消或者其他操作。</li></ol><h2 id="五-取消与关闭"><a href="#五-取消与关闭" class="headerlink" title="五 取消与关闭"></a>五 取消与关闭</h2><ol><li>java没有提供任何机制来安全地终止线程，但提供了中断，这是一种协作机制，能使一个线程终止另一个线程的当前工作。</li><li>任务取消：如果外部代码能在某个操作正常完成之前将其置为完成状态，那么这个操作就是可以取消的（cancellable），这个操作不需要有取消的策略</li><li>中断：当采用设置标志位进行中断的策略时，若中断方法运行时间过长，导致虽然把标志位置为了true，但可能永远无法检测到，因为之前的方法阻塞住了，这样无法中断。对于中断的正确理解是：它并不会真正的中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时候中断自己。</li><li>阻塞库方法。例如：sleep和wait 会检查线程何时中断，并且在发现中断时提前返回，它们响应中断操作包括，清除中断状态，抛出InterruptException。<br>通常，中断是实现取消的最合理的方式。</li><li>中断策略：最合理的中断策略是某种形式的线程级取消操作或服务级取消操作；尽快退出，在必要时进行清理，通知某个所有者线程已经退出。任务不会在其自己拥有的线程中执行，而是在某个服务拥有的线程中执行。</li><li>响应中断：①传递异常，例如使用throws抛出，②恢复中断状态，使上层调用栈进行处理。只有实现了线程中断策略的代码才能屏蔽中断请求。在中断线程之前，应该先了解它的中断策略。</li><li>示例的计时运行：首先是一个反例，由于不知道代用timedRun的线程的中断策略，导致若中断发生在任务正常执行完之后，会执行什么代码我们也不知道；而改进的任务自己启动一个线程执行任务，并设置了中断策略，timedRun任务执行时会调用限时的join，目的是等待任务的执行，防止检测不到异常，待join返回后会检查异常， 若有则抛出。</li><li>future取消：Future 拥有一个cancel 方法，该方法带有一个 boolean 类型的参数 mayinterruptIfRunning，表示取消操作是否成功。（这只是表示任务是否能接受中断，而不是表示任务是否能检测并处理中断。）</li><li>处理不可中断的阻塞：采用newTaskFork封装非标准取消。</li><li>停止基于线程的服务：线程的对象是Thread，其所有者是创建该线程的类。应该有线程的所有者来操作线程，所以要用线程池来中断线程，线程的所有权不能传递。<br>对于持有线程的服务，只要服务的存在时间大于创建现成的方法的存在时间，那么就应该提供生命周期方法</li></ol><h2 id="六-线程池的使用："><a href="#六-线程池的使用：" class="headerlink" title="六 线程池的使用："></a>六 线程池的使用：</h2><ol><li>Executor框架可以将任务的提交和执行解耦，但存在一些任务需要明确的制定执行策略：</li></ol><ul><li>①依赖性任务：任务需要依赖线程池中的其他任务，所以执行策略会受到限制。</li><li>②使用线程封闭机制的任务单线程的executor能确保任务不会并发执行。</li><li>③对响应时间敏感的任务。</li><li>④使用threadLocal的任务：只有线程本地的生命周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义，在线程池中不应该使用ThreadLocal进行值传递。<br>只有当任务都是同类型的并且互相独立时，线程池的性能才能达到最佳。</li></ul><ol start="2"><li>线程饥饿死锁：在单线程的executor中，如果一个任务将另一个任务提交到同一个Executor中，并且等待这个任务的提交结果，那么通常将产生死锁。</li><li>运行时间较长的任务：如果任务阻塞时间过长，会影响线程池的性能。限定任务等待资源的时间可以缓解该问题。</li><li>设置线程池的大小：n(thread) =n(cpu) * u(cpu) *(1+ W/C)</li><li>管理任务队列：通过Runnable和一个链表节点表现等待中的任务，基本任务队列有3种：</li></ol><ul><li>①无界队列：newFixedThreadPool 和 newSingleThreadExecutor 默认使用无界LinkedBlockingQueue，当任务过多时，队列会无限增长。</li><li>②有界队列：配合饱和策略，队列的大小要和线程池的大小一起调整。</li><li>③同步移交（Synchronous Handoff）：对非常大或者无界的线程池，使用此机制避免排队。</li></ul><h2 id="七-避免活跃性危险"><a href="#七-避免活跃性危险" class="headerlink" title="七 避免活跃性危险"></a>七 避免活跃性危险</h2><ol><li>死锁：当线程A持有资源L，同时想要获取资源M；线程B持有资源M，同时想获取资源L，这种情况会产生死锁。数据库系统中，两个事务之间可能发生死锁，系统会 选择一个牺牲者并放弃这个事务，释放资源。JVM当一组线程发生死锁的时候，这些线程将不能使用，恢复方法是终止程序并重启。死锁发生并不是必然的，一般发生在高负载的情况下。</li><li>锁顺序死锁：两个线程试图以不通的顺序获取相同的锁（多个锁）。如果所有线程都以固定的顺序获取锁，在程序中将不会出现锁顺序死锁。</li><li>动态的锁顺序死锁：代码层一个方法中嵌套多个锁，看似外部调用的时候是相同的顺序，但是在方法参数的传递上可能存在想法的顺序，导致锁顺序死锁的发生。所以要制定锁顺序，可以使用System.identityHashCode，返回Object.HashCode值。</li><li>在协作对象之间发生死锁：隐式的会发生锁顺序死锁。如果在持有锁的情况下调用某个外部方法，要小心死锁。</li><li>资源死锁：线程饥饿死锁；当资源池的资源过少，二一个任务需要两个资源池中的资源，相互等待的时候。</li><li>死锁的避免和诊断：两阶段策略检查死锁：①首先找出什么地方获取多个锁，②对所有这些实例进行全局分析</li></ol>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq集群配置</title>
      <link href="/2020/02/10/rabbitmq-cluster-setting/"/>
      <url>/2020/02/10/rabbitmq-cluster-setting/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装erlang"><a href="#1-安装erlang" class="headerlink" title="1.安装erlang"></a>1.安装erlang</h2><p>下载erlang-21.3.8.2-1.el7.x86_64.rpm 包</p><p>rpm -ivh erlang-21.3.8.2-1.el7.x86_64.rpm</p><a id="more"></a><p>报错时可以强制安装：rpm -ivh –force erlang-21.3.8.2-1.el7.x86_64.rpm</p><p>输入erl 检测是否成功 halt().退出</p><p><a href="https://www.erlang-solutions.com/" target="_blank" rel="noopener">https://www.erlang-solutions.com/</a> 可以直接下载deb包安装</p><h2 id="2-rabbitmq"><a href="#2-rabbitmq" class="headerlink" title="2.rabbitmq"></a>2.rabbitmq</h2><p>下载rabbitmq-server-generic-unix-3.7.10.tar.xz包，注意和erlang版本的匹配</p><p>tar -xvf rabbitmq-server-generic-unix-3.7.10.tar.xz</p><p>切换到rabbitmq_server-3.7.10/sbin/   用于启动服务</p><p>调用./rabbitmq-server start 启动后，在/root 目录下找到.erlang.cookie文件， 将其复制到其他的机器，确保环境相同</p><p>启动两个节点为例：</p><p>RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit1 ./rabbitmq-server -detached   指定端口，名称，后台启动 来启动server</p><p>RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit2 ./rabbitmq-server -detached   指定端口，名称，后台启动 来启动server</p><p>在rabbit2上执行</p><p>./rabbitmqctl  -n rabbit2 stop_app</p><p>./rabbitmqctl  -n rabbit2 reset</p><p>./rabbitmqctl  -n rabbit2 join_cluster rabbit1@node6v (node名称在/etc/hosts中指定域名的映射)</p><p>./rabbitmqctl -n rabbit2 start_app</p><p>./rabbitmqctl-n rabbit1 cluster_status 查看集群状态</p><p>设置策略</p><p>/rabbitmqctl  set_policy mypolicy “^” ‘{“ha-mode”:”all”,”ha-sync-mode”:”automatic”}’</p><p>添加账户</p><p>./rabbitmqctl -n rabbit1 add_user xxx xxxxxx</p><p>./rabbitmqctl -n rabbit1 set_permissions -p “/“ xxx “.*” “.*” “.*”</p><p>./rabbitmqctl -n rabbit1 set_user_tags tom administrator</p><p>启动插件</p><p>./rabbitmq-plugins -n rabbit1 enable rabbitmq_management</p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> env </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis集群配置</title>
      <link href="/2019/12/25/redis-cluster-setting/"/>
      <url>/2019/12/25/redis-cluster-setting/</url>
      
        <content type="html"><![CDATA[<p>redis 安装：  下载 解压文件，进入文件夹 make install </p><a id="more"></a><p>redis 集群配置： </p><p>复制多份 redis.conf文件， 集群配置，修改如下信息</p><p>port 9100</p><p>cluster-enabled yes</p><p>cluster-config-file nodes-9100.conf</p><p>启动多个实例脚本如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> /home/xxxxxx/SoftWare/redis-5.0.3/src</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9100/redis.conf  &amp;</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9101/redis.conf  &amp;</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9102/redis.conf  &amp;</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9103/redis.conf  &amp;</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9104/redis.conf  &amp;</span><br><span class="line">redis-server /home/xxxxxx/SoftWare/redis-5.0.3/9105/redis.conf  &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> env </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https</title>
      <link href="/2018/07/01/https/"/>
      <url>/2018/07/01/https/</url>
      
        <content type="html"><![CDATA[<p>补习了http之后又深入的学习了https，记录一下。</p><a id="more"></a><h1 id="HTTPS相关概念"><a href="#HTTPS相关概念" class="headerlink" title="HTTPS相关概念"></a>HTTPS相关概念</h1><p>首先需要了解几个概念：</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>如图：<br><img src="https://github.com/rayl0726/rayl0726.github.io/blob/master/mylist/https2.jpg?raw=true" alt="https1"></p><p>很容易理解，再客户端和服务器段正常通信时，有个第三方的黑客将请求和响应分别截取，篡改信息，这就是中间人攻击。</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>为了确认双方的信息的可靠性，采用共享秘钥的方式，客户端和服务器端都持有一个秘钥用来解密信息，但是新的问题又出现了，如何传递这个秘钥呢？因为中间人攻击的存在，直接传递肯定秘钥会被截取，这样还是没有任何意义。所以还有一种加密方式：非对称加密（RSA）。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>这种方式有两个秘钥，公钥和私钥，公钥用来加密，私钥用来解密，公钥可以分发给所有客户，但是一次性分发到所有的客户端是不现实的，所以还是要由客户端请求获取公钥的方式，这时就又会出现中间人攻击了，如图：<br><img src="https://github.com/rayl0726/rayl0726.github.io/blob/master/mylist/https3.jpg?raw=true" alt="https2"></p><p>正常通信是上面的部分，但是一旦出现中间人，他自己也有一套公钥和私钥，客户端请求很可能得到假的公钥，以后的通信就变成和中间人的通信了。这样还是有问题，怎样解决公钥传递的问题呢？，这时候就又出现了第三方的认证机构CA。</p><h2 id="第三方认证机构CA"><a href="#第三方认证机构CA" class="headerlink" title="第三方认证机构CA"></a>第三方认证机构CA</h2><p>先介绍两个相关概念：数字签名和数字证书。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名　"></a>数字签名　</h3><p>把消息进行hash，用私钥加密该hash，把hash附在发送的消息后；接收方收到后用公钥解密得到消息和hash,把收到的消息hash，然后和收到的hash对比，一致则成功。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>当要验证数字签名的时候要用到公钥，这个公钥如何保证安全呢？这里要用到数字证书，它其实就是把公钥数字签名，保证公钥的安全。</p><p>数字证书内容包括：包含公钥，公钥的数字签名，公钥持有者信息，有效日期等信息。那么如何生成证书呢？</p><p>服务器把公钥1交给CA，CA也有自己的公钥2和私钥2，而他的公钥2是内嵌在浏览器或操作系统中的.他用自己的私钥2加密传递的公钥1生成数字签名，再把公钥1和其他信息生成证书，发送到客户端；客户端用公钥2解密后获取公钥1和公钥1的数字签名，利用数字签名的一套逻辑解密对比，确认证书，也就确认了公钥1的可靠性。</p><h1 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h1><p>如图：<br><img src="https://github.com/rayl0726/rayl0726.github.io/blob/master/mylist/https1.jpg?raw=true" alt="https３"></p><p>整个工作流程其实比较清晰，CA这里用到了摘要的算法，而后面的共享秘钥采用的随机数加密，更加提高了安全性。</p><h1 id="HTTPS的劣势"><a href="#HTTPS的劣势" class="headerlink" title="HTTPS的劣势"></a>HTTPS的劣势</h1><p>https确实提高了通信的安全，但是却提高了CPU和内存的消耗，尤其是RSA算法的解密，所以不可能每次通信都使用https，另外不是每次的通信都需要https这种安全的方式，所以https目前会用在一些特别的场合。</p><p>而且还有数字证书的签发也是需要一大笔费用的，对于一些小型甚至个人的项目采用http通信也许性价比更高。</p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合(List)</title>
      <link href="/2018/06/08/java-collection-list/"/>
      <url>/2018/06/08/java-collection-list/</url>
      
        <content type="html"><![CDATA[<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>List接口继承了Collection接口，List中的元素是有序，可重复的，因为List的存储结构是序列，在内存中开辟的存储空间是连续的，其空间的指针也就对应元素的索引。<br>list对于元素的相等通过equals方法判断，返回true则相等；</p><a id="more"></a><p>List还自带了一个listiterator()方法，返回的是listiterator对象，它继承了iterator，额外提供了向前迭代的功能，同时还能添加元素,ite<br>rator本身只提供了向后遍历，删除元素。<br>List主要的实现类有三个：ArrayList，Vector，LinkedList。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>它的底层实现是数组，所以存储的数据可以按照索引查找，它拥有3种构造器：</p><ol><li>ArrayList()：构造一个初始容量为10的空列表。</li><li>ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。</li><li>ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。</li></ol><p>我们知道ArrayList是可以不用设置初始长度，简单理解为“无限”往里面添加元素（这个无限只是象征），那它的实现是怎样的？<br>这里涉及到了arraylist的扩容，通过构造器我们知道默认的初始容量是10，那超过后怎样添加呢？这里我们查看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行了ensureCapacityInternal()方法，参数就是list现有长度加一；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断list是否为空，为空就把最小容量需求定义为：默认容量（10）和最小容量需求的最大值，再进入ensureExplicitCapacity()方法;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定了最小需求容量后，如果比list现有的数据长度长的话，那就要对list进行扩容了，扩容用grow()方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的方式先把原有list容量扩大为1.5倍，这时候判断扩容后的容量和最小需求容量，若前者比后者还小，那就证明1.5倍不可以，直接让新的容量等于最小需求就可以了，这样下次再添加元素时就可以扩大1.5倍了；还要判断新的容量是否超过list允许的最大容量，这个最大容量JDK1.8定义的是Integer.MAX_VALUE - 8，原因我也不晓得- -|||，如果比最大容量大，进入hugeCapacity()方法；</p><p>在这里先判断是否为负数，然后判断最小容量需求和默认最大容量的大小，大就返回整型的最大值，小或相等就返回默认最大容量；</p><p>最后利用array的copy方法将数组复制到新的数组中elementData = Arrays.copyOf(elementData, newCapacity);<br>这里的操作会用到很多IO，会影响arraylist的使用效率，所以我们应该尽量避免使用arraylist的自动扩容，尽量提前定义好容量；</p><p>ArrayList转换数组可以通过toArray()方法，这个方法的实现其实是 Arrays.copyOf()方法，其实你也可以直接用Arrays的很多方法来操作ArrayList，毕竟有个外号–动态数组；</p><p>ArrayList线程不安全，很明显，里面的方法都没有同步，所以可以用Collections.synchronizedList(),在初始化的时候进行；</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>这是一个上古时代的类，它和ArrayList基本一致但是它是线程安全的，这导致它的性能不如ArrayList，先看看它的构造器：</p><ol><li>Vector()：构造一个初始容量为10的空列表。</li><li>Vector(Collection&lt;? extends E&gt; c)：构造一个包含指定collection的元素的列表，这些元素是按照该collection的迭代器返回它们的顺序排列的。</li><li>Vector(int initialCapacity)：构造一个具有指定初始容量的空列表。</li><li>Vector(int initialCapacity, int capacityIncrement)：构造一个具有指定初始容量和容量增长的空列表。<br>多了一个容量增长，这个参数很明显，在扩容的时候在原来list的基础上加上这个参数就是扩容后的容量，如果没有设置，Vector的扩容是原来的两倍，其他的方法相关与ArrayList基本一致；</li></ol><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>它实现了List<E>, Deque<E>两个接口，它的数据结构就不是序列了，而是双端链表，这样的链式结构带来的好处就是这玩意不用扩容，每个数据在内存中存储不连续，所以使劲加。。。</p><p>构造方法:</p><ol><li>LinkedList(): 构造一个空列表。</li><li>LinkedList(Collection&lt;? extends E&gt; c) :构造一个包含指定collection中的元素的列表，这些元素按其collection的迭代器返回的顺序排列。</li></ol><p>由于是链式结构，所以它在查询的时候很麻烦，要从头一个一个找，不像ArrayList直接按索引查找，但是它在指定位置增加，删除的时候效率很高，只需要把节点的指针改变指的元素就可以，而ArrayList需要把指定位置之后的元素都移动位置，因为存储是连续的，索引都要变动；</p><p>在转换数组的时候，LinkedList明显缓慢，它要通过遍历实现；</p><p>它因为是双端队列，所以自然会有一些队列的方法加入，获取头结点，尾节点等等；</p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合(Set)</title>
      <link href="/2018/06/06/java-collection-set/"/>
      <url>/2018/06/06/java-collection-set/</url>
      
        <content type="html"><![CDATA[<h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>Set接口继承了Collection接口，而且对于其方法基本没有做改动，换句话说Set就是Collection，只是Set中不允许添加重复元素，所以在add重复元素时会返回false。<br>Set主要的实现类有两个个：HashSet，TreeSet。</p><a id="more"></a><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>打开HashSet的源码你会发现这玩意的实现就是HashMap，它拥有4种构造器：</p><ol><li>HashSet()：初始容量是16，加载因子是0.75；</li><li>HashSet(Collection&lt;? extends E&gt; c)：构造一个包含指定Collection中的元素的新Set；</li><li>HashSet(int initialCapacity, float loadFactor)：构造一个新的空Set，其底层HashMap实例具有指定的初始容量和指定的加载因子；</li><li>HashSet(int initialCapacity)：构造一个新的空Set，其底层HashMa 实例具有指定的初始容量和默认的加载因子（0.75）。</li></ol><p>HashSet存储元素的顺序并不是按照存入时的顺序,是按照哈希值来存的，所以取数据也是按照哈希值取得，所以会出现无序的情况。<br>因为Set中不允许添加重复元素，所以对重复元素的判断是有规则的。<br>HashSet不存入重复元素的规则:</p><ol><li>先判断hashcode不同，则元素不重复；</li><li>先判断hashcode相同，但equals返回false；这时就相当于hashmap的散列链表形式存储。</li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet继承了Hashset，但是内部采用双链表的形式，这样保证了元素以插入的顺序保存，但是同样维护链表会导致查询时相对较慢。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>Treeset内部其实是以红黑树的形式存储元素的，也就保证了插入的元素会进行排序<br>由于它实现了Comparable接口和Comparator接口，故内部的排序有两种形式，自然排序和定制排序。同时也要求插入的元素必须实现Comparable接口。<br>Java中实现此接口的如下：</p><ol><li>BigDecimal，BigInteger,所有数值类型的包装类：按照数值大小排序；</li><li>Character：按unicode值排序；</li><li>Boolean：true大于false；</li><li>String：按照字符串中字符的unicode排序；</li><li>Date，Time：按照日期大小；</li></ol><p>4种构造器如下：</p><ol><li>TreeSet()：构造一个新的空Set，该Set根据其元素的自然顺序进行排序;</li><li>TreeSet(Collection&lt;? extends E&gt; c) ：构造一个包含指定Collection元素的新TreeSet，它按照其元素的自然顺序进行排序;</li><li>TreeSet(Comparator&lt;? super E&gt; comparator) ：构造一个新的空TreeSet，它根据指定比较器进行排序;</li><li>TreeSet(SortedSet<E> s) ：构造一个与指定有序Set具有相同映射关系和相同排序的新TreeSet。</li></ol><p>介绍一下两种排序：</p><ol><li><p>自然排序（comparable）：将元素按照升序排列，也就是当treeset添加了一个元素后，会调用compareTo()方法与红黑树中的元素比较，放到合适的位置。这里对于相等元素的判断是依赖于compareTo()方法的返回值，若是0则相等；同时对于equals()方法尽量保持与compareTo()方法的返回值一致，否则会比较麻烦。</p></li><li><p>定制排序（comparator）：相当于自定义一个比较器，比较的规则也是自己定义，在构造TreeSet的时候就实现比较器Comparator，进而对元素进行排序。</p></li></ol><p>因为TreeSet比HashSet有序，所以在方法中多了查找第一个，最后一个，前一个，后一个四个定位方法以及可以用来截取TreeSet的三个方法。</p><p>2018-06-06</p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http</title>
      <link href="/2018/06/06/http/"/>
      <url>/2018/06/06/http/</url>
      
        <content type="html"><![CDATA[<p>近期专门重头学习了一遍http协议，记录一下学习的心得，以及以后忘记了再来查找。</p><a id="more"></a><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><ol><li>MAC</li><li>ARP</li><li>URI</li><li>URL</li><li>RFC</li><li>SSL</li><li>TLS</li></ol><h1 id="1-简述TCP-IP"><a href="#1-简述TCP-IP" class="headerlink" title="1.简述TCP/IP"></a>1.简述TCP/IP</h1><p>提到http就不得不提tcp/ip协议，我们通常使用的网络都是以tcp/ip为基础的，而http其实算是在其应用层使用的一个协议，所以先了解一下tcp/ip的分层结构：<br><img src="https://github.com/rayl0726/rayl0726.github.io/blob/master/mylist/http1.png?raw=true" alt="http1"><br>从高到底分为应用层，传输层，网络层，链路层；<br>分层的设计结构可以模块化，便于自由设计；</p><h2 id="1-1应用层"><a href="#1-1应用层" class="headerlink" title="1.1应用层"></a>1.1应用层</h2><p>向用户提供应用服务的通信结构；</p><p>在该层主要存在：http，ftp，dns等</p><p>dns主要用于对域名解析为ip地址</p><h2 id="1-2传输层"><a href="#1-2传输层" class="headerlink" title="1.2传输层"></a>1.2传输层</h2><p>提供数据传输服务</p><p>该层主要存在：tcp，udp；</p><p>在tcp协议中将数据分为数据包进行传输，并且用了传说中的三次握手和四次分手的方式；</p><h2 id="1-3网络层"><a href="#1-3网络层" class="headerlink" title="1.3网络层"></a>1.3网络层</h2><p>传输数据包</p><p>该层主要存在：ip；</p><p>ip协议则利用了MAC可以中转传输;</p><h2 id="1-4链路层"><a href="#1-4链路层" class="headerlink" title="1.4链路层"></a>1.4链路层</h2><p>处理网络硬件相关</p><p>该层主要存在：操作系统，网卡，驱动，光纤等；</p><p>数据的传输是从发送端的高层到底层，接收端的底层到高层，每一层的数据在首部会封装关键字，便于解析识别。</p><h1 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2 HTTP协议"></a>2 HTTP协议</h1><p>http协议是由客户端请求，服务端响应请求并返回，服务端在没有请求的情况下不会主动响应；</p><p>http协议是无状态协议，也就是传输的信息不会保存；<br>http协议通过uri定位资源；</p><p>http协议的连接在1.0中每次通信都要连接和断开一次，这种方式以不适用于当前的网络通信，所以在1.1中有了持久连接（keep-alive），也就是只要一方没有提出断开，则tcp连接将保持；</p><p>http协议本来是请求-响应后才能法下一个请求，但是有了持久连接，完全可以不等响应直接发送多个请求，而响应也可以依次返回；</p><p>http协议由于无状态，所以考虑一种情况：当我们登陆一个页面跳转后，我们在下一个页面如何保存登陆信息？这时出现了cookie技术，客户端请求，服务器端响应，并在响应报文首部中写入set-cookie信息；客户端再请求，请求报文首部中就有了上一次的cookie信息，服务器端响应，发现熟悉的cookie信息，就把之前的状态信息一并返回。</p><p>http协议还存在一个内容协商，也就是客户端发来的请求，服务器这有多个资源符合，例如不同语言。通过在请求报文首部中加入accept等，可以让服务器判断出要返回哪些资源，这个就是内容协商。</p><p>关于http/2.0，先得说说SPDY，这是一个谷歌开发的实验性协议，主要是想通过对http协议的限制作出优化，进而减少网页加载的时间，其目标大致分为：</p><ul><li>页面加载时间降低50%；</li><li>无需网站作者修改任何内容；</li><li>把部署复杂性降低，不改变网络基础设施；</li></ul><blockquote><p>SPDY通过优先级和多路复用，使得只需要建立一个TCP连接即可传送网页内容及图片等资源。SPDY中广泛应用了TLS加密，传输内容也均以gzip或DEFLATE格式压缩（与HTTP不同，HTTP的头部并不会被压缩）。另外，除了像HTTP的网页服务器被动的等待浏览器发起请求外，SPDY的网页服务器还可以主动推送内容。</p></blockquote><blockquote><p>SPDY并不用于取代HTTP，它只是修改了HTTP的请求与应答在网络上传输的方式；这意味着只需增加一个SPDY传输层，现有的所有服务端应用均不用做任何修改。 当使用SPDY的方式传输，HTTP请求会被处理、标记简化和压缩。比如，每一个SPDY端点会持续跟踪每一个在之前的请求中已经发送的HTTP报文头部，从而避免重复发送还未改变的头部。而还未发送的报文的数据部分将在被压缩后被发送。</p></blockquote><blockquote><p>2015年9月，Google 宣布了计划，移除对SPDY的支持，拥抱 HTTP/2.0，并将在Chrome 51中生效。</p></blockquote><p>所以有了http/2.0，具体2.0版本的好处如下：</p><p>协议改进了对于报文的解析，采用二进制，这样只有0和1的组合将更加便捷和稳定；同时对于request采用共享连接诶的方式，在一个连接中可以存在多个request，每个都有自己的id，服务器端根据id可以分类到不同的请求；http是文本传输，根据结构其首部header部分的内容可能会非常多，传输起来很消耗资源，http/2.0可以压缩header，减少传输消耗；最后还有就是增加了server push功能。</p><h1 id="3-HTTP报文结构"><a href="#3-HTTP报文结构" class="headerlink" title="3 HTTP报文结构"></a>3 HTTP报文结构</h1><p>请求报文结构：</p><table align="center"><tr><th>说明</th> <th colspan="6" >内容</th></tr><td>请求行</td><td>方法</td><td>sp</td><td>URI</td><td>sp</td><td>协议版本</td><td>CR+LF</td><tr><td>首部行</td><td colspan="2">首部字段名：</td><td>sp</td><td colspan="2">值</td><td>CR+LF</td></tr><tr><td colspan="7">CR+LF</td></tr><tr><td colspan="7">主体</td></tr></table><p>响应报文结构：</p><table align="center"><tr><th>说明</th> <th colspan="6">内容</th></tr><td>响应行</td><td>协议版本</td><td>sp</td><td>状态码</td><td>sp</td><td>状态信息</td><td>CR+LF</td><tr><td>首部行</td> <td colspan="2">首部字段名：</td><td>sp</td><td colspan="2">值</td><td>CR+LF</td></tr><tr><td colspan="7">CR+LF</td></tr><tr><td colspan="7">主体</td></tr></table><h1 id="4-HTTP请求方法"><a href="#4-HTTP请求方法" class="headerlink" title="4 HTTP请求方法"></a>4 HTTP请求方法</h1><table><thead><tr><th>版本</th><th>请求方法</th></tr></thead><tbody><tr><td>HTTP/0.9</td><td>只存在一种GET方法，请求也只有GET <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 一行</td></tr><tr><td>HTTP/1.0</td><td>支持POST，GET，HEAD</td></tr><tr><td>HTTP/1.1</td><td>支持POST，GET，HEAD，新增五种：OPTIONS，PUT，DELETE，TRACE，CONNECT</td></tr><tr><td>HTTP/2.0</td><td>同HTTP/1.1</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求获取指定资源，并返回主体。正常应该只用于数据的获取。</td></tr><tr><td>HEAD</td><td>请求一个与GET请求响应相同的响应，但是响应没有响应的主体。用于查看服务端的性能。</td></tr><tr><td>POST</td><td>向指定的资源提交数据，请求服务器的处理。用于表单提交，文件上传等，数据存在于请求的主体中。PS：post请求可能会对现有资源作出更改。</td></tr><tr><td>OPTIONS</td><td>用来查询针对请求URI指定资源支持的方法。</td></tr><tr><td>PUT</td><td>PUT方法用来传输文件，就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全问题，故一般不用。</td></tr><tr><td>DELETE</td><td>指明客户端想让服务器删除某个资源，与PUT方法相反，按URI删除指定资源。</td></tr><tr><td>TRACE</td><td>客户端可以对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法。</td></tr><tr><td>CONNECT</td><td>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</td></tr></tbody></table><p>由于GET和POST方法的使用个最为广泛，故对其作出对比：</p><ol><li><p>GET方法用于信息获取，它是安全的（安全：指非修改信息，如数据库方面的信息），而POST方法是用于修改服务器上资源的请求；</p></li><li><p>GET请求的数据会附在URL之后，而POST方法提交的数据则放置在HTTP报文实体的主体里，所以POST方法的安全性比GET方法要高；</p></li><li><p>GET方法传输的数据量一般限制在2KB，其原因在于：GET是通过URL提交数据，而URL本身对于数据没有限制，但是不同的浏览器对于URL是有限制的，比如IE浏览器对于URL的限制为2KB，而Chrome，FireFox浏览器理论上对于URL是没有限制的，它真正的限制取决于操作系统本身；POST方法对于数据大小是无限制的，真正影响到数据大小的是服务器处理程序的能力。</p></li></ol><h1 id="5-HTTP状态码"><a href="#5-HTTP状态码" class="headerlink" title="5 HTTP状态码"></a>5 HTTP状态码</h1><h2 id="5-1-1XX"><a href="#5-1-1XX" class="headerlink" title="5.1 1XX"></a>5.1 1XX</h2><p>信息性状态码，请求正在处理中</p><h2 id="5-2-2XX"><a href="#5-2-2XX" class="headerlink" title="5.2 2XX"></a>5.2 2XX</h2><p>成功状态码，请求正常处理完毕</p><ul><li>200 OK 请求正常处理；</li><li>204 No Content 请求成功，但是没有资源返回；</li><li>206 Partial Content 请求部分资源。</li></ul><h2 id="5-3-3XX"><a href="#5-3-3XX" class="headerlink" title="5.3 3XX"></a>5.3 3XX</h2><p>重定向状态码，需要附加操作完成请求</p><ul><li>301 Moved Permanently 永久重定向，也就是资源的URI更新了，之前保存书签要更新了，永久性的，规定不能将请求POST改变为GET</li><li>302 Found 临时重定向，资源的URI更新了，但是以后可能还改变，规定不能将请求POST改变为GET</li><li>303 See Other 类似302，但应该使用GET方法请求</li><li>304 Not Modified 资源找到了，但是不符合附加条件</li><li>307 Temporary Redirect 临时重定向，且不会从POST变成GET</li></ul><h2 id="5-4-4XX"><a href="#5-4-4XX" class="headerlink" title="5.4 4XX"></a>5.4 4XX</h2><p>客户端错误状态码，服务器无法处理请求</p><ul><li>400 Bad Request 请求报文语法错误</li><li>401 Unauthorized 表示请求需要通过认证（BASIC，DIGEST）首次会返回认证页面，以后默认认证失败</li><li>403 Forbidden 服务器拒绝访问</li><li>404 Not Found 服务器无法找到请求资源</li></ul><h2 id="5-5-5XX"><a href="#5-5-5XX" class="headerlink" title="5.5 5XX"></a>5.5 5XX</h2><p>服务端错误状态码，服务器端处理请求失败</p><ul><li>500 Internal Server Error 服务器出现错误</li><li>503 Service Unavailable 服务器暂时超载或者停机维护</li></ul><h1 id="6-HTTP通信的服务器"><a href="#6-HTTP通信的服务器" class="headerlink" title="6 HTTP通信的服务器"></a>6 HTTP通信的服务器</h1><p>http1.1支持但台服务器搭建多个站点，也就是不同的域名可能指向相同的ip地址；</p><p>http通信中可以存在转发的程序：代理，网关，隧道；</p><h2 id="6-1-代理"><a href="#6-1-代理" class="headerlink" title="6.1 代理"></a>6.1 代理</h2><p>简单来说就像一个中间人，将客户端的请求转发给服务器端，并把响应返回到客户端；</p><p>既然有了代理，如果只转发岂不是很浪费，于是有了：缓存代理，透明代理</p><h3 id="6-1-1-缓存代理"><a href="#6-1-1-缓存代理" class="headerlink" title="6.1.1 缓存代理"></a>6.1.1 缓存代理</h3><p>代理转发资源时，先把从源服务器端获得的资源缓存在服务器，下次再收到相同的请求时就直接返回缓存资源；</p><p>但是缓存是存在有效期的，长时间不更新肯定是不可以的，所以代理服务器会向原服务器求证缓存资源的有效性，若失效则重新获取；</p><p>缓存的资源除了存在代理服务器中，还可以存在客户端的磁盘中，效果一样，同样存在有效期。</p><h3 id="6-1-2-透明代理"><a href="#6-1-2-透明代理" class="headerlink" title="6.1.2 透明代理"></a>6.1.2 透明代理</h3><p>不改变请求报文，响应报文的代理；</p><h3 id="6-1-3-不透明代理"><a href="#6-1-3-不透明代理" class="headerlink" title="6.1.3 不透明代理"></a>6.1.3 不透明代理</h3><p>改变请求报文，响应报文的代理;</p><h2 id="6-2-网关"><a href="#6-2-网关" class="headerlink" title="6.2 网关"></a>6.2 网关</h2><p>类似代理，但是它可以提供非http协议的通信，而且有高安全性，所以可以应用在购物结算等；</p><h2 id="6-3-隧道"><a href="#6-3-隧道" class="headerlink" title="6.3 隧道"></a>6.3 隧道</h2><p>非常形象，将通信线路加密（ssl等），保证安全通信.</p><h1 id="7-HTTP首部"><a href="#7-HTTP首部" class="headerlink" title="7 HTTP首部"></a>7 HTTP首部</h1><p>首部有很多，可以直接在网上查找使用。</p><h1 id="8-HTTP不同版本的比较"><a href="#8-HTTP不同版本的比较" class="headerlink" title="8 HTTP不同版本的比较"></a>8 HTTP不同版本的比较</h1><p>主要对比1.0和1.1吧</p><table><thead><tr><th>比较点</th><th>1.0</th><th>1.1</th></tr></thead><tbody><tr><td>keep-alive</td><td>没有持久链接，每次请求后都会断开tcp</td><td>一方未提出断开，tcp保持连接</td></tr><tr><td>host</td><td>在报文的uri部分指定好了链接域，没有host首部</td><td>可以在host首部指定域名</td></tr><tr><td>range</td><td>没有range首部</td><td>在range首部可以请求部分资源，减小带宽消耗</td></tr><tr><td>请求方法</td><td>3种</td><td>多了5种</td></tr><tr><td>状态码</td><td>16个</td><td>24个</td></tr></tbody></table><p>参考文档：</p><p><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a></p><p><a href="https://www.cnblogs.com/foodoir/p/5911099.html" target="_blank" rel="noopener">HTTP请求方法详解</a></p><p><a href="https://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a></p>]]></content>
      
      
      <categories>
          
          <category> tech </category>
          
          <category> net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
